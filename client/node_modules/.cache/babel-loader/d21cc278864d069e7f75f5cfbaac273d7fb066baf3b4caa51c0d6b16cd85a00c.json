{"ast":null,"code":"// Simple helpers to compute balances and chart data from raw expenses.\n// We treat \"split\" as EVEN among all participants.\n// Participants come from `splitWith` (comma-separated). If missing, we use [paidBy, ...paidTo].\n// Each expense shape we expect: { description, amount, paidBy, paidTo?, splitWith?, category?, date?, settled? }\n\nconst norm = s => String(s || \"\").trim().toLowerCase();\nconst parseList = s => Array.from(new Set(String(s || \"\").split(/[,\\s]+/).map(x => norm(x)).filter(Boolean)));\nfunction participantsForExpense(e) {\n  const paidBy = norm(e.paidBy);\n  const splitWith = parseList(e.splitWith);\n  let parts = splitWith.length ? splitWith : [paidBy, ...parseList(e.paidTo)];\n  if (!parts.includes(paidBy)) parts.unshift(paidBy);\n  // unique + non-empty already by parseList; ensure again\n  parts = Array.from(new Set(parts.filter(Boolean)));\n  return {\n    paidBy,\n    parts\n  };\n}\nfunction toNumber(x) {\n  const n = Number(x);\n  return Number.isFinite(n) ? n : 0;\n}\nexport function computeFromExpenses(myEmail, expenses) {\n  const me = norm(myEmail);\n  const balances = {}; // friendEmail => net (pos: they owe me; neg: I owe them)\n  let owedToMe = 0;\n  let youOwe = 0;\n  const recent = []; // for recent activity\n  const now = new Date();\n\n  // Category totals for current month (my share only)\n  const catTotals = {}; // category => total amount for me\n  const month = now.getMonth();\n  const year = now.getFullYear();\n  (expenses || []).forEach(e => {\n    const amt = toNumber(e.amount);\n    if (!amt) return;\n    const {\n      paidBy,\n      parts\n    } = participantsForExpense(e);\n    const share = parts.length ? amt / parts.length : 0;\n\n    // Track category if this expense is in the current month\n    const dt = e.date ? new Date(e.date) : null;\n    const inThisMonth = dt && dt.getMonth() === month && dt.getFullYear() === year;\n    const cat = String(e.category || \"Other\");\n\n    // Build recent activity row (keep raw date string)\n    recent.push({\n      description: e.description || \"Expense\",\n      amount: amt,\n      paidBy,\n      parts,\n      date: e.date || null,\n      category: cat,\n      settled: !!e.settled,\n      id: e.id\n    });\n\n    // If I'm not a participant, skip balances & my share\n    const iAmIn = parts.includes(me);\n    if (!iAmIn && me !== paidBy) return;\n    if (me === paidBy) {\n      // Everyone else owes me their share\n      parts.forEach(p => {\n        if (p === me) return;\n        balances[p] = (balances[p] || 0) + share;\n        owedToMe += share;\n      });\n      if (inThisMonth) {\n        // my own share counts as spend too (optional choice). Here: count MY share only.\n        catTotals[cat] = (catTotals[cat] || 0) + share;\n      }\n    } else {\n      // Someone else paid; if I'm a participant, I owe the payer my share\n      balances[paidBy] = (balances[paidBy] || 0) - share;\n      youOwe += share;\n      if (inThisMonth) {\n        catTotals[cat] = (catTotals[cat] || 0) + share;\n      }\n    }\n  });\n  const totalBalance = owedToMe - youOwe;\n\n  // Per-friend array, sorted by absolute amount desc\n  const perFriend = Object.entries(balances).map(([friend, value]) => ({\n    friend,\n    value\n  })).sort((a, b) => Math.abs(b.value) - Math.abs(a.value));\n\n  // Recent: sort by date (fallback: id as timestamp) desc, keep 6\n  recent.sort((a, b) => {\n    const ta = a.date ? +new Date(a.date) : a.id ? parseInt(a.id, 36) : 0;\n    const tb = b.date ? +new Date(b.date) : b.id ? parseInt(b.id, 36) : 0;\n    return tb - ta;\n  });\n  const recent6 = recent.slice(0, 6);\n\n  // Chart data (top 6 categories sorted by value)\n  const chartData = Object.entries(catTotals).map(([label, value]) => ({\n    label,\n    value\n  })).sort((a, b) => b.value - a.value).slice(0, 6);\n  const chartTotal = chartData.reduce((s, x) => s + x.value, 0);\n  return {\n    totals: {\n      totalBalance,\n      youOwe,\n      owedToMe\n    },\n    perFriend,\n    recent: recent6,\n    chart: {\n      data: chartData,\n      total: chartTotal\n    }\n  };\n}\nexport function formatCurrency(n) {\n  const v = Math.round((Number(n) || 0) * 100) / 100;\n  return `₹ ${v.toLocaleString(\"en-IN\", {\n    maximumFractionDigits: 2\n  })}`;\n}\nexport function timeAgo(dateString) {\n  if (!dateString) return \"\";\n  const d = new Date(dateString);\n  const diff = (Date.now() - +d) / 1000;\n  if (diff < 60) return `${Math.floor(diff)}s ago`;\n  if (diff < 3600) return `${Math.floor(diff / 60)}m ago`;\n  if (diff < 86400) return `${Math.floor(diff / 3600)}h ago`;\n  return d.toLocaleDateString();\n}","map":{"version":3,"names":["norm","s","String","trim","toLowerCase","parseList","Array","from","Set","split","map","x","filter","Boolean","participantsForExpense","e","paidBy","splitWith","parts","length","paidTo","includes","unshift","toNumber","n","Number","isFinite","computeFromExpenses","myEmail","expenses","me","balances","owedToMe","youOwe","recent","now","Date","catTotals","month","getMonth","year","getFullYear","forEach","amt","amount","share","dt","date","inThisMonth","cat","category","push","description","settled","id","iAmIn","p","totalBalance","perFriend","Object","entries","friend","value","sort","a","b","Math","abs","ta","parseInt","tb","recent6","slice","chartData","label","chartTotal","reduce","totals","chart","data","total","formatCurrency","v","round","toLocaleString","maximumFractionDigits","timeAgo","dateString","d","diff","floor","toLocaleDateString"],"sources":["/Users/queen/Downloads/Budget Tracker/client/src/utils/finance.js"],"sourcesContent":["// Simple helpers to compute balances and chart data from raw expenses.\n// We treat \"split\" as EVEN among all participants.\n// Participants come from `splitWith` (comma-separated). If missing, we use [paidBy, ...paidTo].\n// Each expense shape we expect: { description, amount, paidBy, paidTo?, splitWith?, category?, date?, settled? }\n\nconst norm = (s) =>\n  String(s || \"\")\n    .trim()\n    .toLowerCase();\nconst parseList = (s) =>\n  Array.from(\n    new Set(\n      String(s || \"\")\n        .split(/[,\\s]+/)\n        .map((x) => norm(x))\n        .filter(Boolean)\n    )\n  );\n\nfunction participantsForExpense(e) {\n  const paidBy = norm(e.paidBy);\n  const splitWith = parseList(e.splitWith);\n  let parts = splitWith.length ? splitWith : [paidBy, ...parseList(e.paidTo)];\n  if (!parts.includes(paidBy)) parts.unshift(paidBy);\n  // unique + non-empty already by parseList; ensure again\n  parts = Array.from(new Set(parts.filter(Boolean)));\n  return { paidBy, parts };\n}\n\nfunction toNumber(x) {\n  const n = Number(x);\n  return Number.isFinite(n) ? n : 0;\n}\n\nexport function computeFromExpenses(myEmail, expenses) {\n  const me = norm(myEmail);\n  const balances = {}; // friendEmail => net (pos: they owe me; neg: I owe them)\n  let owedToMe = 0;\n  let youOwe = 0;\n\n  const recent = []; // for recent activity\n  const now = new Date();\n\n  // Category totals for current month (my share only)\n  const catTotals = {}; // category => total amount for me\n  const month = now.getMonth();\n  const year = now.getFullYear();\n\n  (expenses || []).forEach((e) => {\n    const amt = toNumber(e.amount);\n    if (!amt) return;\n\n    const { paidBy, parts } = participantsForExpense(e);\n    const share = parts.length ? amt / parts.length : 0;\n\n    // Track category if this expense is in the current month\n    const dt = e.date ? new Date(e.date) : null;\n    const inThisMonth =\n      dt && dt.getMonth() === month && dt.getFullYear() === year;\n    const cat = String(e.category || \"Other\");\n\n    // Build recent activity row (keep raw date string)\n    recent.push({\n      description: e.description || \"Expense\",\n      amount: amt,\n      paidBy,\n      parts,\n      date: e.date || null,\n      category: cat,\n      settled: !!e.settled,\n      id: e.id,\n    });\n\n    // If I'm not a participant, skip balances & my share\n    const iAmIn = parts.includes(me);\n    if (!iAmIn && me !== paidBy) return;\n\n    if (me === paidBy) {\n      // Everyone else owes me their share\n      parts.forEach((p) => {\n        if (p === me) return;\n        balances[p] = (balances[p] || 0) + share;\n        owedToMe += share;\n      });\n      if (inThisMonth) {\n        // my own share counts as spend too (optional choice). Here: count MY share only.\n        catTotals[cat] = (catTotals[cat] || 0) + share;\n      }\n    } else {\n      // Someone else paid; if I'm a participant, I owe the payer my share\n      balances[paidBy] = (balances[paidBy] || 0) - share;\n      youOwe += share;\n\n      if (inThisMonth) {\n        catTotals[cat] = (catTotals[cat] || 0) + share;\n      }\n    }\n  });\n\n  const totalBalance = owedToMe - youOwe;\n\n  // Per-friend array, sorted by absolute amount desc\n  const perFriend = Object.entries(balances)\n    .map(([friend, value]) => ({ friend, value }))\n    .sort((a, b) => Math.abs(b.value) - Math.abs(a.value));\n\n  // Recent: sort by date (fallback: id as timestamp) desc, keep 6\n  recent.sort((a, b) => {\n    const ta = a.date ? +new Date(a.date) : a.id ? parseInt(a.id, 36) : 0;\n    const tb = b.date ? +new Date(b.date) : b.id ? parseInt(b.id, 36) : 0;\n    return tb - ta;\n  });\n  const recent6 = recent.slice(0, 6);\n\n  // Chart data (top 6 categories sorted by value)\n  const chartData = Object.entries(catTotals)\n    .map(([label, value]) => ({ label, value }))\n    .sort((a, b) => b.value - a.value)\n    .slice(0, 6);\n\n  const chartTotal = chartData.reduce((s, x) => s + x.value, 0);\n\n  return {\n    totals: { totalBalance, youOwe, owedToMe },\n    perFriend,\n    recent: recent6,\n    chart: { data: chartData, total: chartTotal },\n  };\n}\n\nexport function formatCurrency(n) {\n  const v = Math.round((Number(n) || 0) * 100) / 100;\n  return `₹ ${v.toLocaleString(\"en-IN\", { maximumFractionDigits: 2 })}`;\n}\n\nexport function timeAgo(dateString) {\n  if (!dateString) return \"\";\n  const d = new Date(dateString);\n  const diff = (Date.now() - +d) / 1000;\n  if (diff < 60) return `${Math.floor(diff)}s ago`;\n  if (diff < 3600) return `${Math.floor(diff / 60)}m ago`;\n  if (diff < 86400) return `${Math.floor(diff / 3600)}h ago`;\n  return d.toLocaleDateString();\n}\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}