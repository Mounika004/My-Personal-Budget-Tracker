{"ast":null,"code":"// src/redux/reducers/userReducer.js\n\n// Stable initial shape so first render never crashes.\nconst initialState = {\n  user: {\n    _id: null,\n    username: \"\",\n    email: \"\",\n    friends: [],\n    expensis: [] // canonical client-side list (dashboard reads from this)\n  }\n};\n\n// Build a simple signature so we can dedupe items that represent the same expense.\n// We use description, amount, date, and \"user\" (friend) if present.\nfunction expSig(e) {\n  const d = e && e.inp && e.inp.description || e && e.description || \"\";\n  const a = e && e.inp && e.inp.amount || e && e.amount || \"\";\n  const dt = e && e.inp && e.inp.date || e && e.date || \"\";\n  const u = e && e.user || \"\";\n  return String(d).trim() + \"|\" + String(a) + \"|\" + String(dt) + \"|\" + String(u);\n}\n\n// Prefer the item with a real _id over a temp one. If both have ids, keep the incoming.\nfunction choosePreferReal(existing, incoming) {\n  const exId = existing && existing._id;\n  const inId = incoming && incoming._id;\n  const exIsTemp = exId && String(exId).startsWith(\"temp-\");\n  const inIsTemp = inId && String(inId).startsWith(\"temp-\");\n  if (!exId && inId) return incoming;\n  if (exIsTemp && !inIsTemp) return incoming;\n  // Otherwise keep incoming (latest from server), or existing if incoming is falsy\n  return incoming || existing;\n}\n\n// Merge two arrays of expenses with dedupe by signature and preference for real (server) docs.\nfunction mergeExpenseArrays(baseArr, incomingArr) {\n  const out = [];\n  const bySig = new Map();\n  (baseArr || []).forEach(e => {\n    const s = expSig(e);\n    bySig.set(s, e);\n  });\n  (incomingArr || []).forEach(e => {\n    const s = expSig(e);\n    if (bySig.has(s)) {\n      const chosen = choosePreferReal(bySig.get(s), e);\n      bySig.set(s, chosen);\n    } else {\n      bySig.set(s, e);\n    }\n  });\n  bySig.forEach(val => out.push(val));\n  return out;\n}\nexport const userReducer = (state = initialState, action) => {\n  switch (action.type) {\n    case \"AddUser\":\n      {\n        const doc = action.payload || {};\n        // Some APIs return { user: { ... } }\n        const incoming = doc && doc.user && (doc.user.username || doc.user.friends || doc.user.expensis || doc.user.expenses) ? doc.user : doc;\n\n        // Friends: use incoming if it's an array, else keep current\n        const nextFriends = Array.isArray(incoming.friends) ? incoming.friends : state.user.friends;\n\n        // Normalize expenses key (server may send \"expensis\" or \"expenses\")\n        const incomingExpRaw = Array.isArray(incoming.expensis) ? incoming.expensis : Array.isArray(incoming.expenses) ? incoming.expenses : undefined;\n\n        // If server sent an array, MERGE it with what we already have (do not clobber)\n        const nextExpensis = Array.isArray(incomingExpRaw) ? mergeExpenseArrays(state.user.expensis, incomingExpRaw) : state.user.expensis;\n        return {\n          user: {\n            ...state.user,\n            ...incoming,\n            friends: nextFriends,\n            expensis: nextExpensis\n          }\n        };\n      }\n\n    // Append one or many items locally so UI updates immediately\n    case \"APPEND_EXPENSES\":\n      {\n        const add = Array.isArray(action.payload) ? action.payload : [action.payload];\n        const merged = mergeExpenseArrays(state.user.expensis, add);\n        return {\n          user: {\n            ...state.user,\n            expensis: merged\n          }\n        };\n      }\n    case \"LOGOUT\":\n      return initialState;\n    default:\n      return state;\n  }\n};","map":{"version":3,"names":["initialState","user","_id","username","email","friends","expensis","expSig","e","d","inp","description","a","amount","dt","date","u","String","trim","choosePreferReal","existing","incoming","exId","inId","exIsTemp","startsWith","inIsTemp","mergeExpenseArrays","baseArr","incomingArr","out","bySig","Map","forEach","s","set","has","chosen","get","val","push","userReducer","state","action","type","doc","payload","expenses","nextFriends","Array","isArray","incomingExpRaw","undefined","nextExpensis","add","merged"],"sources":["/Users/queen/Downloads/Budget Tracker/client/src/redux/reducers/userReducer.js"],"sourcesContent":["// src/redux/reducers/userReducer.js\r\n\r\n// Stable initial shape so first render never crashes.\r\nconst initialState = {\r\n  user: {\r\n    _id: null,\r\n    username: \"\",\r\n    email: \"\",\r\n    friends: [],\r\n    expensis: [], // canonical client-side list (dashboard reads from this)\r\n  },\r\n};\r\n\r\n// Build a simple signature so we can dedupe items that represent the same expense.\r\n// We use description, amount, date, and \"user\" (friend) if present.\r\nfunction expSig(e) {\r\n  const d = (e && e.inp && e.inp.description) || (e && e.description) || \"\";\r\n  const a = (e && e.inp && e.inp.amount) || (e && e.amount) || \"\";\r\n  const dt = (e && e.inp && e.inp.date) || (e && e.date) || \"\";\r\n  const u = (e && e.user) || \"\";\r\n  return (\r\n    String(d).trim() + \"|\" + String(a) + \"|\" + String(dt) + \"|\" + String(u)\r\n  );\r\n}\r\n\r\n// Prefer the item with a real _id over a temp one. If both have ids, keep the incoming.\r\nfunction choosePreferReal(existing, incoming) {\r\n  const exId = existing && existing._id;\r\n  const inId = incoming && incoming._id;\r\n  const exIsTemp = exId && String(exId).startsWith(\"temp-\");\r\n  const inIsTemp = inId && String(inId).startsWith(\"temp-\");\r\n\r\n  if (!exId && inId) return incoming;\r\n  if (exIsTemp && !inIsTemp) return incoming;\r\n  // Otherwise keep incoming (latest from server), or existing if incoming is falsy\r\n  return incoming || existing;\r\n}\r\n\r\n// Merge two arrays of expenses with dedupe by signature and preference for real (server) docs.\r\nfunction mergeExpenseArrays(baseArr, incomingArr) {\r\n  const out = [];\r\n  const bySig = new Map();\r\n\r\n  (baseArr || []).forEach((e) => {\r\n    const s = expSig(e);\r\n    bySig.set(s, e);\r\n  });\r\n\r\n  (incomingArr || []).forEach((e) => {\r\n    const s = expSig(e);\r\n    if (bySig.has(s)) {\r\n      const chosen = choosePreferReal(bySig.get(s), e);\r\n      bySig.set(s, chosen);\r\n    } else {\r\n      bySig.set(s, e);\r\n    }\r\n  });\r\n\r\n  bySig.forEach((val) => out.push(val));\r\n  return out;\r\n}\r\n\r\nexport const userReducer = (state = initialState, action) => {\r\n  switch (action.type) {\r\n    case \"AddUser\": {\r\n      const doc = action.payload || {};\r\n      // Some APIs return { user: { ... } }\r\n      const incoming =\r\n        doc &&\r\n        doc.user &&\r\n        (doc.user.username ||\r\n          doc.user.friends ||\r\n          doc.user.expensis ||\r\n          doc.user.expenses)\r\n          ? doc.user\r\n          : doc;\r\n\r\n      // Friends: use incoming if it's an array, else keep current\r\n      const nextFriends = Array.isArray(incoming.friends)\r\n        ? incoming.friends\r\n        : state.user.friends;\r\n\r\n      // Normalize expenses key (server may send \"expensis\" or \"expenses\")\r\n      const incomingExpRaw = Array.isArray(incoming.expensis)\r\n        ? incoming.expensis\r\n        : Array.isArray(incoming.expenses)\r\n        ? incoming.expenses\r\n        : undefined;\r\n\r\n      // If server sent an array, MERGE it with what we already have (do not clobber)\r\n      const nextExpensis = Array.isArray(incomingExpRaw)\r\n        ? mergeExpenseArrays(state.user.expensis, incomingExpRaw)\r\n        : state.user.expensis;\r\n\r\n      return {\r\n        user: {\r\n          ...state.user,\r\n          ...incoming,\r\n          friends: nextFriends,\r\n          expensis: nextExpensis,\r\n        },\r\n      };\r\n    }\r\n\r\n    // Append one or many items locally so UI updates immediately\r\n    case \"APPEND_EXPENSES\": {\r\n      const add = Array.isArray(action.payload)\r\n        ? action.payload\r\n        : [action.payload];\r\n      const merged = mergeExpenseArrays(state.user.expensis, add);\r\n      return { user: { ...state.user, expensis: merged } };\r\n    }\r\n\r\n    case \"LOGOUT\":\r\n      return initialState;\r\n\r\n    default:\r\n      return state;\r\n  }\r\n};\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}