{"ast":null,"code":"export function toCSV(expenses = []) {\n  const headers = [\"id\", \"description\", \"amount\", \"paidBy\", \"paidTo\", \"splitWith\", \"category\", \"date\", \"settled\", \"type\"];\n  const lines = [headers.join(\",\")];\n  expenses.forEach(e => {\n    const row = headers.map(h => {\n      let v = e[h] !== undefined ? String(e[h]) : \"\";\n      if (v.includes(\",\") || v.includes('\"') || v.includes(\"\\n\")) v = `\"${v.replace(/\"/g, '\"\"')}\"`;\n      return v;\n    });\n    lines.push(row.join(\",\"));\n  });\n  return lines.join(\"\\n\");\n}\nexport function parseCSV(text) {\n  // Simple CSV parser (no complex quotes across lines). For production, use a lib.\n  const lines = text.split(/\\r?\\n/).filter(Boolean);\n  if (!lines.length) return {\n    headers: [],\n    rows: []\n  };\n  const headers = lines[0].split(\",\").map(h => h.trim());\n  const rows = lines.slice(1).map(line => {\n    // naive split respecting simple quotes\n    const cells = [];\n    let cur = \"\",\n      q = false;\n    for (let i = 0; i < line.length; i++) {\n      const ch = line[i];\n      if (ch === '\"') {\n        q = !q;\n        continue;\n      }\n      if (ch === \",\" && !q) {\n        cells.push(cur);\n        cur = \"\";\n        continue;\n      }\n      cur += ch;\n    }\n    cells.push(cur);\n    const obj = {};\n    headers.forEach((h, idx) => obj[h] = cells[idx] !== undefined ? cells[idx].replace(/\"\"/g, '\"') : \"\");\n    return obj;\n  });\n  return {\n    headers,\n    rows\n  };\n}","map":{"version":3,"names":["toCSV","expenses","headers","lines","join","forEach","e","row","map","h","v","undefined","String","includes","replace","push","parseCSV","text","split","filter","Boolean","length","rows","trim","slice","line","cells","cur","q","i","ch","obj","idx"],"sources":["/Users/queen/Downloads/Budget Tracker/client/src/utils/csv.js"],"sourcesContent":["export function toCSV(expenses = []) {\n  const headers = [\n    \"id\",\n    \"description\",\n    \"amount\",\n    \"paidBy\",\n    \"paidTo\",\n    \"splitWith\",\n    \"category\",\n    \"date\",\n    \"settled\",\n    \"type\",\n  ];\n  const lines = [headers.join(\",\")];\n  expenses.forEach((e) => {\n    const row = headers.map((h) => {\n      let v = e[h] !== undefined ? String(e[h]) : \"\";\n      if (v.includes(\",\") || v.includes('\"') || v.includes(\"\\n\"))\n        v = `\"${v.replace(/\"/g, '\"\"')}\"`;\n      return v;\n    });\n    lines.push(row.join(\",\"));\n  });\n  return lines.join(\"\\n\");\n}\n\nexport function parseCSV(text) {\n  // Simple CSV parser (no complex quotes across lines). For production, use a lib.\n  const lines = text.split(/\\r?\\n/).filter(Boolean);\n  if (!lines.length) return { headers: [], rows: [] };\n  const headers = lines[0].split(\",\").map((h) => h.trim());\n  const rows = lines.slice(1).map((line) => {\n    // naive split respecting simple quotes\n    const cells = [];\n    let cur = \"\",\n      q = false;\n    for (let i = 0; i < line.length; i++) {\n      const ch = line[i];\n      if (ch === '\"') {\n        q = !q;\n        continue;\n      }\n      if (ch === \",\" && !q) {\n        cells.push(cur);\n        cur = \"\";\n        continue;\n      }\n      cur += ch;\n    }\n    cells.push(cur);\n    const obj = {};\n    headers.forEach(\n      (h, idx) =>\n        (obj[h] =\n          cells[idx] !== undefined ? cells[idx].replace(/\"\"/g, '\"') : \"\")\n    );\n    return obj;\n  });\n  return { headers, rows };\n}\n"],"mappings":"AAAA,OAAO,SAASA,KAAKA,CAACC,QAAQ,GAAG,EAAE,EAAE;EACnC,MAAMC,OAAO,GAAG,CACd,IAAI,EACJ,aAAa,EACb,QAAQ,EACR,QAAQ,EACR,QAAQ,EACR,WAAW,EACX,UAAU,EACV,MAAM,EACN,SAAS,EACT,MAAM,CACP;EACD,MAAMC,KAAK,GAAG,CAACD,OAAO,CAACE,IAAI,CAAC,GAAG,CAAC,CAAC;EACjCH,QAAQ,CAACI,OAAO,CAAEC,CAAC,IAAK;IACtB,MAAMC,GAAG,GAAGL,OAAO,CAACM,GAAG,CAAEC,CAAC,IAAK;MAC7B,IAAIC,CAAC,GAAGJ,CAAC,CAACG,CAAC,CAAC,KAAKE,SAAS,GAAGC,MAAM,CAACN,CAAC,CAACG,CAAC,CAAC,CAAC,GAAG,EAAE;MAC9C,IAAIC,CAAC,CAACG,QAAQ,CAAC,GAAG,CAAC,IAAIH,CAAC,CAACG,QAAQ,CAAC,GAAG,CAAC,IAAIH,CAAC,CAACG,QAAQ,CAAC,IAAI,CAAC,EACxDH,CAAC,GAAG,IAAIA,CAAC,CAACI,OAAO,CAAC,IAAI,EAAE,IAAI,CAAC,GAAG;MAClC,OAAOJ,CAAC;IACV,CAAC,CAAC;IACFP,KAAK,CAACY,IAAI,CAACR,GAAG,CAACH,IAAI,CAAC,GAAG,CAAC,CAAC;EAC3B,CAAC,CAAC;EACF,OAAOD,KAAK,CAACC,IAAI,CAAC,IAAI,CAAC;AACzB;AAEA,OAAO,SAASY,QAAQA,CAACC,IAAI,EAAE;EAC7B;EACA,MAAMd,KAAK,GAAGc,IAAI,CAACC,KAAK,CAAC,OAAO,CAAC,CAACC,MAAM,CAACC,OAAO,CAAC;EACjD,IAAI,CAACjB,KAAK,CAACkB,MAAM,EAAE,OAAO;IAAEnB,OAAO,EAAE,EAAE;IAAEoB,IAAI,EAAE;EAAG,CAAC;EACnD,MAAMpB,OAAO,GAAGC,KAAK,CAAC,CAAC,CAAC,CAACe,KAAK,CAAC,GAAG,CAAC,CAACV,GAAG,CAAEC,CAAC,IAAKA,CAAC,CAACc,IAAI,CAAC,CAAC,CAAC;EACxD,MAAMD,IAAI,GAAGnB,KAAK,CAACqB,KAAK,CAAC,CAAC,CAAC,CAAChB,GAAG,CAAEiB,IAAI,IAAK;IACxC;IACA,MAAMC,KAAK,GAAG,EAAE;IAChB,IAAIC,GAAG,GAAG,EAAE;MACVC,CAAC,GAAG,KAAK;IACX,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGJ,IAAI,CAACJ,MAAM,EAAEQ,CAAC,EAAE,EAAE;MACpC,MAAMC,EAAE,GAAGL,IAAI,CAACI,CAAC,CAAC;MAClB,IAAIC,EAAE,KAAK,GAAG,EAAE;QACdF,CAAC,GAAG,CAACA,CAAC;QACN;MACF;MACA,IAAIE,EAAE,KAAK,GAAG,IAAI,CAACF,CAAC,EAAE;QACpBF,KAAK,CAACX,IAAI,CAACY,GAAG,CAAC;QACfA,GAAG,GAAG,EAAE;QACR;MACF;MACAA,GAAG,IAAIG,EAAE;IACX;IACAJ,KAAK,CAACX,IAAI,CAACY,GAAG,CAAC;IACf,MAAMI,GAAG,GAAG,CAAC,CAAC;IACd7B,OAAO,CAACG,OAAO,CACb,CAACI,CAAC,EAAEuB,GAAG,KACJD,GAAG,CAACtB,CAAC,CAAC,GACLiB,KAAK,CAACM,GAAG,CAAC,KAAKrB,SAAS,GAAGe,KAAK,CAACM,GAAG,CAAC,CAAClB,OAAO,CAAC,KAAK,EAAE,GAAG,CAAC,GAAG,EAClE,CAAC;IACD,OAAOiB,GAAG;EACZ,CAAC,CAAC;EACF,OAAO;IAAE7B,OAAO;IAAEoB;EAAK,CAAC;AAC1B","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}