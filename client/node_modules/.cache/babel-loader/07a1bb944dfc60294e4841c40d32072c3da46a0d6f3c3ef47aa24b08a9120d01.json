{"ast":null,"code":"// src/redux/reducers/userReducer.js\n\nconst initialState = {\n  user: {\n    _id: null,\n    username: \"\",\n    email: \"\",\n    friends: [],\n    expensis: [] // canonical list used by the dashboard\n  }\n};\nexport const userReducer = (state = initialState, action) => {\n  switch (action.type) {\n    case \"AddUser\":\n      {\n        const doc = action.payload || {};\n        const incoming = doc.user && (doc.user.username || doc.user.friends || doc.user.expensis || doc.user.expenses) ? doc.user : doc;\n\n        // friends: if server sends an array use it; else keep current\n        const nextFriends = Array.isArray(incoming.friends) ? incoming.friends : state.user.friends;\n\n        // normalize expenses key and DO NOT overwrite with an empty array\n        const incomingExpRaw = Array.isArray(incoming.expensis) ? incoming.expensis : Array.isArray(incoming.expenses) ? incoming.expenses : undefined;\n        const nextExpensis = Array.isArray(incomingExpRaw) ? incomingExpRaw.length > 0 ? incomingExpRaw : state.user.expensis // <- keep local if server empty\n        : state.user.expensis;\n        return {\n          user: {\n            ...state.user,\n            ...incoming,\n            friends: nextFriends,\n            expensis: nextExpensis\n          }\n        };\n      }\n\n    // append immediately so the UI updates before the refresh completes\n    case \"APPEND_EXPENSES\":\n      {\n        const add = Array.isArray(action.payload) ? action.payload : [action.payload];\n\n        // simple de-dupe by a signature (handles temp + real items)\n        const sig = e => {\n          const d = e.inp && e.inp.description || e.description || \"\";\n          const a = e.inp && e.inp.amount || e.amount || \"\";\n          const dt = e.inp && e.inp.date || e.date || \"\";\n          const u = e.user || \"\";\n          return `${d}|${a}|${dt}|${u}`;\n        };\n        const existing = state.user.expensis || [];\n        const seen = new Set(existing.map(sig));\n        const merged = existing.slice();\n        add.forEach(e => {\n          const s = sig(e);\n          if (!seen.has(s)) {\n            seen.add(s);\n            merged.push(e);\n          }\n        });\n        return {\n          user: {\n            ...state.user,\n            expensis: merged\n          }\n        };\n      }\n    case \"LOGOUT\":\n      return initialState;\n    default:\n      return state;\n  }\n};","map":{"version":3,"names":["initialState","user","_id","username","email","friends","expensis","userReducer","state","action","type","doc","payload","incoming","expenses","nextFriends","Array","isArray","incomingExpRaw","undefined","nextExpensis","length","add","sig","e","d","inp","description","a","amount","dt","date","u","existing","seen","Set","map","merged","slice","forEach","s","has","push"],"sources":["/Users/queen/Downloads/Budget Tracker/client/src/redux/reducers/userReducer.js"],"sourcesContent":["// src/redux/reducers/userReducer.js\r\n\r\nconst initialState = {\r\n  user: {\r\n    _id: null,\r\n    username: \"\",\r\n    email: \"\",\r\n    friends: [],\r\n    expensis: [], // canonical list used by the dashboard\r\n  },\r\n};\r\n\r\nexport const userReducer = (state = initialState, action) => {\r\n  switch (action.type) {\r\n    case \"AddUser\": {\r\n      const doc = action.payload || {};\r\n      const incoming =\r\n        doc.user &&\r\n        (doc.user.username ||\r\n          doc.user.friends ||\r\n          doc.user.expensis ||\r\n          doc.user.expenses)\r\n          ? doc.user\r\n          : doc;\r\n\r\n      // friends: if server sends an array use it; else keep current\r\n      const nextFriends = Array.isArray(incoming.friends)\r\n        ? incoming.friends\r\n        : state.user.friends;\r\n\r\n      // normalize expenses key and DO NOT overwrite with an empty array\r\n      const incomingExpRaw = Array.isArray(incoming.expensis)\r\n        ? incoming.expensis\r\n        : Array.isArray(incoming.expenses)\r\n        ? incoming.expenses\r\n        : undefined;\r\n\r\n      const nextExpensis = Array.isArray(incomingExpRaw)\r\n        ? incomingExpRaw.length > 0\r\n          ? incomingExpRaw\r\n          : state.user.expensis // <- keep local if server empty\r\n        : state.user.expensis;\r\n\r\n      return {\r\n        user: {\r\n          ...state.user,\r\n          ...incoming,\r\n          friends: nextFriends,\r\n          expensis: nextExpensis,\r\n        },\r\n      };\r\n    }\r\n\r\n    // append immediately so the UI updates before the refresh completes\r\n    case \"APPEND_EXPENSES\": {\r\n      const add = Array.isArray(action.payload)\r\n        ? action.payload\r\n        : [action.payload];\r\n\r\n      // simple de-dupe by a signature (handles temp + real items)\r\n      const sig = (e) => {\r\n        const d = (e.inp && e.inp.description) || e.description || \"\";\r\n        const a = (e.inp && e.inp.amount) || e.amount || \"\";\r\n        const dt = (e.inp && e.inp.date) || e.date || \"\";\r\n        const u = e.user || \"\";\r\n        return `${d}|${a}|${dt}|${u}`;\r\n      };\r\n\r\n      const existing = state.user.expensis || [];\r\n      const seen = new Set(existing.map(sig));\r\n      const merged = existing.slice();\r\n\r\n      add.forEach((e) => {\r\n        const s = sig(e);\r\n        if (!seen.has(s)) {\r\n          seen.add(s);\r\n          merged.push(e);\r\n        }\r\n      });\r\n\r\n      return {\r\n        user: { ...state.user, expensis: merged },\r\n      };\r\n    }\r\n\r\n    case \"LOGOUT\":\r\n      return initialState;\r\n\r\n    default:\r\n      return state;\r\n  }\r\n};\r\n"],"mappings":"AAAA;;AAEA,MAAMA,YAAY,GAAG;EACnBC,IAAI,EAAE;IACJC,GAAG,EAAE,IAAI;IACTC,QAAQ,EAAE,EAAE;IACZC,KAAK,EAAE,EAAE;IACTC,OAAO,EAAE,EAAE;IACXC,QAAQ,EAAE,EAAE,CAAE;EAChB;AACF,CAAC;AAED,OAAO,MAAMC,WAAW,GAAGA,CAACC,KAAK,GAAGR,YAAY,EAAES,MAAM,KAAK;EAC3D,QAAQA,MAAM,CAACC,IAAI;IACjB,KAAK,SAAS;MAAE;QACd,MAAMC,GAAG,GAAGF,MAAM,CAACG,OAAO,IAAI,CAAC,CAAC;QAChC,MAAMC,QAAQ,GACZF,GAAG,CAACV,IAAI,KACPU,GAAG,CAACV,IAAI,CAACE,QAAQ,IAChBQ,GAAG,CAACV,IAAI,CAACI,OAAO,IAChBM,GAAG,CAACV,IAAI,CAACK,QAAQ,IACjBK,GAAG,CAACV,IAAI,CAACa,QAAQ,CAAC,GAChBH,GAAG,CAACV,IAAI,GACRU,GAAG;;QAET;QACA,MAAMI,WAAW,GAAGC,KAAK,CAACC,OAAO,CAACJ,QAAQ,CAACR,OAAO,CAAC,GAC/CQ,QAAQ,CAACR,OAAO,GAChBG,KAAK,CAACP,IAAI,CAACI,OAAO;;QAEtB;QACA,MAAMa,cAAc,GAAGF,KAAK,CAACC,OAAO,CAACJ,QAAQ,CAACP,QAAQ,CAAC,GACnDO,QAAQ,CAACP,QAAQ,GACjBU,KAAK,CAACC,OAAO,CAACJ,QAAQ,CAACC,QAAQ,CAAC,GAChCD,QAAQ,CAACC,QAAQ,GACjBK,SAAS;QAEb,MAAMC,YAAY,GAAGJ,KAAK,CAACC,OAAO,CAACC,cAAc,CAAC,GAC9CA,cAAc,CAACG,MAAM,GAAG,CAAC,GACvBH,cAAc,GACdV,KAAK,CAACP,IAAI,CAACK,QAAQ,CAAC;QAAA,EACtBE,KAAK,CAACP,IAAI,CAACK,QAAQ;QAEvB,OAAO;UACLL,IAAI,EAAE;YACJ,GAAGO,KAAK,CAACP,IAAI;YACb,GAAGY,QAAQ;YACXR,OAAO,EAAEU,WAAW;YACpBT,QAAQ,EAAEc;UACZ;QACF,CAAC;MACH;;IAEA;IACA,KAAK,iBAAiB;MAAE;QACtB,MAAME,GAAG,GAAGN,KAAK,CAACC,OAAO,CAACR,MAAM,CAACG,OAAO,CAAC,GACrCH,MAAM,CAACG,OAAO,GACd,CAACH,MAAM,CAACG,OAAO,CAAC;;QAEpB;QACA,MAAMW,GAAG,GAAIC,CAAC,IAAK;UACjB,MAAMC,CAAC,GAAID,CAAC,CAACE,GAAG,IAAIF,CAAC,CAACE,GAAG,CAACC,WAAW,IAAKH,CAAC,CAACG,WAAW,IAAI,EAAE;UAC7D,MAAMC,CAAC,GAAIJ,CAAC,CAACE,GAAG,IAAIF,CAAC,CAACE,GAAG,CAACG,MAAM,IAAKL,CAAC,CAACK,MAAM,IAAI,EAAE;UACnD,MAAMC,EAAE,GAAIN,CAAC,CAACE,GAAG,IAAIF,CAAC,CAACE,GAAG,CAACK,IAAI,IAAKP,CAAC,CAACO,IAAI,IAAI,EAAE;UAChD,MAAMC,CAAC,GAAGR,CAAC,CAACvB,IAAI,IAAI,EAAE;UACtB,OAAO,GAAGwB,CAAC,IAAIG,CAAC,IAAIE,EAAE,IAAIE,CAAC,EAAE;QAC/B,CAAC;QAED,MAAMC,QAAQ,GAAGzB,KAAK,CAACP,IAAI,CAACK,QAAQ,IAAI,EAAE;QAC1C,MAAM4B,IAAI,GAAG,IAAIC,GAAG,CAACF,QAAQ,CAACG,GAAG,CAACb,GAAG,CAAC,CAAC;QACvC,MAAMc,MAAM,GAAGJ,QAAQ,CAACK,KAAK,CAAC,CAAC;QAE/BhB,GAAG,CAACiB,OAAO,CAAEf,CAAC,IAAK;UACjB,MAAMgB,CAAC,GAAGjB,GAAG,CAACC,CAAC,CAAC;UAChB,IAAI,CAACU,IAAI,CAACO,GAAG,CAACD,CAAC,CAAC,EAAE;YAChBN,IAAI,CAACZ,GAAG,CAACkB,CAAC,CAAC;YACXH,MAAM,CAACK,IAAI,CAAClB,CAAC,CAAC;UAChB;QACF,CAAC,CAAC;QAEF,OAAO;UACLvB,IAAI,EAAE;YAAE,GAAGO,KAAK,CAACP,IAAI;YAAEK,QAAQ,EAAE+B;UAAO;QAC1C,CAAC;MACH;IAEA,KAAK,QAAQ;MACX,OAAOrC,YAAY;IAErB;MACE,OAAOQ,KAAK;EAChB;AACF,CAAC","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}